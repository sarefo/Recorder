<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ABC Notation Player</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0 auto;
            padding: 0 20px;
        }

        .control-bar {
            position: sticky;
            display: flex;
            justify-content: center;
            top: 0;
            gap: 8px;
            z-index: 101;
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
        }

        .control-bar button {
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        #abc-notation {
            margin-top: 20px;
        }

        .abcjs-container {
            padding-top: 200px;
        }

        .feedback {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            display: none;
        }

        section .fingering-diagram {
            pointer-events: none;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 3px;
            padding: 2px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .fingering-hole {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            border: 1px solid #000;
            margin: 1px 0;
        }

        .abcjs-container.minimized #reference-row {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .minimize-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .minimize-label {
            font-size: 12px;
            color: #666;
        }

        #chart-toggle {
            padding: 4px 8px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            cursor: pointer;
        }

        #reference-row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 0;
            transition: all 0.3s ease;
            overflow-x: auto;
        }

        .abcjs-container.minimized #reference-row {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
    </style>
</head>

<body>
    <div class="control-bar">
        <button id="copy-button" title="Copy ABC notation (Ctrl+C)">To Clipboard</button>
        <button id="paste-button" title="Paste ABC notation (Ctrl+V)">From Clipboard</button>

        <button id="transpose-up" title="Transpose up">▲</button>
        <button id="transpose-down" title="Transpose down">▼</button>

        <button id="play-button" title="Play/Stop">▶</button>
        <button id="restart-button" title="Restart">⟳</button>

        <div class="minimize-controls">
            <span class="minimize-label">Chart</span>
            <button id="chart-toggle" title="Minimize/Expand reference row">&#x2212;</button>
        </div>
    </div>

    <!-- Add MIDI status display -->
    <div id="midi-status"></div>
    <div id="reference-row" class="fingering-grid"></div>
    <div id="abc-notation"></div>
    <div id="feedback" class="feedback"></div>

    <script src="https://cdn.jsdelivr.net/npm/abcjs@6.0.0/dist/abcjs-basic-min.js"></script>
    <script>
        /**
         * Utility functions for the application
         */
        const Utils = {
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            showFeedback(message, duration = 2000) {
                const feedback = document.getElementById('feedback');
                feedback.textContent = message;
                feedback.style.display = 'block';
                setTimeout(() => {
                    feedback.style.display = 'none';
                }, duration);
            },

            async copyToClipboard(text) {
                try {
                    await navigator.clipboard.writeText(text);
                    this.showFeedback('ABC notation copied to clipboard!');
                    return true;
                } catch (err) {
                    console.error('Failed to copy:', err);
                    alert('Could not copy to clipboard. Please check browser permissions.');
                    return false;
                }
            },

            async readFromClipboard() {
                try {
                    return await navigator.clipboard.readText();
                } catch (err) {
                    console.error('Failed to paste:', err);
                    alert('Could not access clipboard. Please check browser permissions.');
                    return null;
                }
            }
        };

        /**
         * Manages fingering diagrams and their display
         */
        class FingeringManager {
            constructor(config) {
                this.config = config;
                this.fingeringData = {
                    'C': { left: ['c', 'c', 'c', 'c'], right: ['c', 'c', 'c', 'c'] },
                    '^C': { left: ['c', 'c', 'c', 'c'], right: ['c', 'c', 'c', 'p'] },
                    'D': { left: ['c', 'c', 'c', 'c'], right: ['c', 'c', 'c', 'o'] },
                    '^D': { left: ['c', 'c', 'c', 'c'], right: ['c', 'c', 'p', 'o'] },
                    'E': { left: ['c', 'c', 'c', 'c'], right: ['c', 'c', 'o', 'o'] },
                    'F': { left: ['c', 'c', 'c', 'c'], right: ['c', 'o', 'c', 'c'] },
                    '^F': { left: ['c', 'c', 'c', 'c'], right: ['o', 'c', 'c', 'o'] },
                    'G': { left: ['c', 'c', 'c', 'c'], right: ['o', 'o', 'o', 'o'] },
                    '^G': { left: ['c', 'c', 'c', 'o'], right: ['c', 'c', 'o', 'o'] },
                    'A': { left: ['c', 'c', 'c', 'o'], right: ['o', 'o', 'o', 'o'] },
                    '^A': { left: ['c', 'c', 'o', 'c'], right: ['c', 'o', 'o', 'o'] },
                    'B': { left: ['c', 'c', 'o', 'o'], right: ['o', 'o', 'o', 'o'] },
                    'c': { left: ['c', 'o', 'c', 'o'], right: ['o', 'o', 'o', 'o'] },
                    '^c': { left: ['o', 'c', 'c', 'o'], right: ['o', 'o', 'o', 'o'] },
                    'd': { left: ['o', 'o', 'c', 'o'], right: ['o', 'o', 'o', 'o'] },
                    '^d': { left: ['o', 'o', 'c', 'c'], right: ['c', 'c', 'c', 'o'] },
                    'e': { left: ['p', 'c', 'c', 'c'], right: ['c', 'c', 'o', 'o'] },
                    'f': { left: ['p', 'c', 'c', 'c'], right: ['c', 'o', 'c', 'o'] },
                    '^f': { left: ['p', 'c', 'c', 'c'], right: ['o', 'c', 'o', 'o'] },
                    'g': { left: ['p', 'c', 'c', 'c'], right: ['o', 'o', 'o', 'o'] },
                    '^g': { left: ['p', 'c', 'c', 'o'], right: ['c', 'o', 'o', 'o'] },
                    'a': { left: ['p', 'c', 'c', 'o'], right: ['o', 'o', 'o', 'o'] }
                };

                // German fingering variations
                this.fingeringDataGerman = {
                    'F': { left: ['c', 'c', 'c', 'c'], right: ['c', 'o', 'o', 'o'] },
                    '^F': { left: ['c', 'c', 'c', 'c'], right: ['o', 'c', 'c', 'c'] },
                    '^c': { left: ['c', 'o', 'o', 'o'], right: ['o', 'o', 'o', 'o'] },
                    'f': { left: ['p', 'c', 'c', 'c'], right: ['c', 'o', 'o', 'o'] },
                    '^f': { left: ['p', 'c', 'c', 'c'], right: ['o', 'c', 'o', 'c'] },
                    '^g': { left: ['p', 'c', 'c', 'c'], right: ['o', 'c', 'c', 'c'] }
                };

                this.currentFingeringSystem = 'german';
                this.showFingering = true;
            }

            createHole(state, isFirstLeftHole = false) {
                const config = this.config;

                const hole = document.createElement('div');
                hole.style.width = `${config.holeSize}px`;
                hole.style.height = `${config.holeSize}px`;
                hole.style.borderRadius = '50%';
                hole.style.border = `${config.holeBorder}px solid #000`;
                hole.style.margin = `${config.holeSpacing}px 0`;

                const filledColor = isFirstLeftHole ? '#888' : 'black';

                if (state === 'c') {
                    hole.style.backgroundColor = filledColor;
                } else if (state === 'p') {
                    hole.style.background = `linear-gradient(45deg, ${filledColor} 50%, white 50%)`;
                } else {
                    hole.style.backgroundColor = 'white';
                }

                return hole;
            }

            createFingeringDiagram(fingeringData, noteName) {
                const config = this.config;

                // Create container
                const diagram = document.createElement('div');
                diagram.className = 'fingering-diagram';
                diagram.setAttribute('data-state', 'neutral');
                diagram.style.display = 'flex';
                diagram.style.flexDirection = 'column';
                diagram.style.alignItems = 'center';
                diagram.style.backgroundColor = config.backgroundColor;
                diagram.style.borderRadius = `${config.borderRadius}px`;
                diagram.style.padding = '3px';
                diagram.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
                diagram.style.pointerEvents = 'auto'; // Make clickable

                // Add click event to cycle through states
                diagram.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const currentState = diagram.getAttribute('data-state');
                    let newState;

                    if (currentState === 'neutral') {
                        newState = 'red';
                        diagram.style.backgroundColor = config.redColor;
                    } else if (currentState === 'red') {
                        newState = 'green';
                        diagram.style.backgroundColor = config.greenColor;
                    } else {
                        newState = 'neutral';
                        diagram.style.backgroundColor = config.backgroundColor;
                    }

                    diagram.setAttribute('data-state', newState);
                });

                // Add note name label if enabled
                if (config.showLabels && noteName) {
                    const noteLabel = document.createElement('div');
                    noteLabel.textContent = noteName;
                    noteLabel.style.fontSize = `${config.fontSizeNote}px`;
                    noteLabel.style.fontWeight = 'bold';
                    noteLabel.style.marginBottom = '2px';
                    diagram.appendChild(noteLabel);
                }

                // Create two columns for left and right hand
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.gap = `${config.columnSpacing}px`;

                // Left hand column
                const leftCol = document.createElement('div');
                leftCol.style.display = 'flex';
                leftCol.style.flexDirection = 'column';
                leftCol.style.alignItems = 'center';

                // Right hand column
                const rightCol = document.createElement('div');
                rightCol.style.display = 'flex';
                rightCol.style.flexDirection = 'column';
                rightCol.style.alignItems = 'center';

                // Create holes
                fingeringData.left.forEach((state, index) => {
                    leftCol.appendChild(this.createHole(state, index === 0)); // Pass true for first hole
                });

                fingeringData.right.forEach(state => {
                    rightCol.appendChild(this.createHole(state));
                });

                container.appendChild(leftCol);
                container.appendChild(rightCol);
                diagram.appendChild(container);

                return diagram;
            }

            getFingeringForNote(noteName) {
                // Try direct match first
                if (this.currentFingeringSystem === 'german' && this.fingeringDataGerman[noteName]) {
                    return this.fingeringDataGerman[noteName];
                }

                if (this.fingeringData[noteName]) {
                    return this.fingeringData[noteName];
                }

                // Try enharmonic equivalents if needed
                const noteMatch = noteName.match(/([_^=]*)([A-Ga-g])([,']*)/);
                if (!noteMatch) return null;

                const [, accidental, noteLetter, octaveMarkers] = noteMatch;

                // Map for common enharmonic equivalents
                const enharmonicMap = {
                    // Original mappings for C4-B4 octave (uppercase)
                    '_B': '^A', '^A': '_B',
                    '_E': '^D', '^D': '_E',
                    '_A': '^G', '^G': '_A',
                    '_D': '^C', '^C': '_D',
                    '_G': '^F', '^F': '_G',

                    // Additional mappings for C5-B5 octave (lowercase)
                    '_b': '^a', '^a': '_b',
                    '_e': '^d', '^d': '_e',
                    '_a': '^g', '^g': '_a',
                    '_d': '^c', '^c': '_d',
                    '_g': '^f', '^f': '_g'
                };

                // Try looking up with an enharmonic equivalent
                const enharmonicKey = accidental + noteLetter;
                if (enharmonicMap[enharmonicKey]) {
                    const enharmonic = enharmonicMap[enharmonicKey] + octaveMarkers;

                    if (this.currentFingeringSystem === 'german' && this.fingeringDataGerman[enharmonic]) {
                        return this.fingeringDataGerman[enharmonic];
                    }

                    if (this.fingeringData[enharmonic]) {
                        return this.fingeringData[enharmonic];
                    }
                }

                return null;
            }

            toggleFingeringSystem() {
                this.currentFingeringSystem = (this.currentFingeringSystem === 'baroque') ? 'german' : 'baroque';
                return this.currentFingeringSystem;
            }

            clearFingeringDiagrams() {
                const existing = document.getElementById('fingering-layer');
                if (existing) existing.remove();
            }

            populateReferenceRow() {
                const referenceRow = document.getElementById('reference-row');
                if (!referenceRow) return;

                // Clear any existing content
                referenceRow.innerHTML = '';

                // Define reference notes (C4 to A5)
                const referenceNotes = [
                    'C', '^C', 'D', '^D', 'E', 'F', '^F', 'G', '^G', 'A', '^A', 'B',
                    'c', '^c', 'd', '^d', 'e', 'f', '^f', 'g', '^g', 'a'
                ];

                // Create a fingering diagram for each reference note
                referenceNotes.forEach(noteName => {
                    const fingeringData = this.getFingeringForNote(noteName);
                    if (!fingeringData) return;

                    const container = document.createElement('div');
                    container.className = 'chart-container';
                    container.style.padding = '8px';
                    container.style.border = '1px solid #ddd';
                    container.style.borderRadius = '8px';
                    container.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';

                    if (noteName.includes('^')) {
                        container.style.borderWidth = '3px';
                        container.style.borderColor = '#000';
                    }

                    const noteLabel = document.createElement('div');
                    noteLabel.textContent = noteName;
                    noteLabel.style.textAlign = 'center';
                    noteLabel.style.marginBottom = '8px';
                    noteLabel.style.fontWeight = 'bold';

                    const diagram = this.createFingeringDiagram(fingeringData, noteName);

                    container.appendChild(noteLabel);
                    container.appendChild(diagram);
                    referenceRow.appendChild(container);
                });

                // Start with reference row minimized
                document.querySelector('.abcjs-container').classList.add('minimized');
            }
        }

        /**
         * Handles music notation extraction and processing
         */
        class NotationParser {
            constructor() {
                this.currentAbc = `X:1
T:Chromatic Scale
M:4/4
L:1/4
Q:1/4=120
K:C
C _e F`;
                //C ^C D ^D | E F ^F G | ^G A ^A B |c ^c d ^d | e f ^f g |^g a z2 |`;
            }

            parseAbcSections(abc) {
                const sections = {
                    header: [],
                    key: '',
                    notes: []
                };

                const lines = abc.split('\n');
                let inNotes = false;

                for (const line of lines) {
                    if (line.trim().startsWith('K:')) {
                        sections.key = line;
                        inNotes = true;
                    } else if (!inNotes) {
                        sections.header.push(line);
                    } else {
                        sections.notes.push(line);
                    }
                }

                return sections;
            }

            reconstructAbc(sections) {
                return [
                    ...sections.header,
                    sections.key,
                    ...sections.notes
                ].join('\n');
            }

            getAccidentalsForKey(key) {
                // Standardize key format
                const normalizedKey = key.replace('#', '♯').replace('b', '♭');
                const isMinor = normalizedKey.endsWith('m');
                const baseKey = isMinor ? normalizedKey.slice(0, -1) : normalizedKey;

                // Key signature definitions (which notes are affected)
                const keySignatures = {
                    // Major keys with sharps
                    'C': {},  // No accidentals
                    'G': { 'F': '^' },  // F♯
                    'D': { 'F': '^', 'C': '^' },  // F♯, C♯
                    'A': { 'F': '^', 'C': '^', 'G': '^' },  // F♯, C♯, G♯
                    'E': { 'F': '^', 'C': '^', 'G': '^', 'D': '^' },  // F♯, C♯, G♯, D♯
                    'B': { 'F': '^', 'C': '^', 'G': '^', 'D': '^', 'A': '^' },  // F♯, C♯, G♯, D♯, A♯
                    'F♯': { 'F': '^', 'C': '^', 'G': '^', 'D': '^', 'A': '^', 'E': '^' },  // F♯, C♯, G♯, D♯, A♯, E♯
                    'C♯': { 'F': '^', 'C': '^', 'G': '^', 'D': '^', 'A': '^', 'E': '^', 'B': '^' },  // F♯, C♯, G♯, D♯, A♯, E♯, B♯

                    // Major keys with flats
                    'F': { 'B': '_' },  // B♭
                    'B♭': { 'B': '_', 'E': '_' },  // B♭, E♭
                    'E♭': { 'B': '_', 'E': '_', 'A': '_' },  // B♭, E♭, A♭
                    'A♭': { 'B': '_', 'E': '_', 'A': '_', 'D': '_' },  // B♭, E♭, A♭, D♭
                    'D♭': { 'B': '_', 'E': '_', 'A': '_', 'D': '_', 'G': '_' },  // B♭, E♭, A♭, D♭, G♭
                    'G♭': { 'B': '_', 'E': '_', 'A': '_', 'D': '_', 'G': '_', 'C': '_' },  // B♭, E♭, A♭, D♭, G♭, C♭
                    'C♭': { 'B': '_', 'E': '_', 'A': '_', 'D': '_', 'G': '_', 'C': '_', 'F': '_' },  // B♭, E♭, A♭, D♭, G♭, C♭, F♭
                };

                // Map minor keys to their relative major
                const minorToRelativeMajor = {
                    'Am': 'C', 'Em': 'G', 'Bm': 'D', 'F♯m': 'A', 'C♯m': 'E', 'G♯m': 'B', 'D♯m': 'F♯', 'A♯m': 'C♯',
                    'Dm': 'F', 'Gm': 'B♭', 'Cm': 'E♭', 'Fm': 'A♭', 'B♭m': 'D♭', 'E♭m': 'G♭', 'A♭m': 'C♭'
                };

                if (isMinor) {
                    return keySignatures[minorToRelativeMajor[normalizedKey]] || {};
                }

                return keySignatures[baseKey] || {};
            }

            extractNotesFromAbc() {
                // Extract the music part (after K: line)
                const parts = this.currentAbc.split(/K:[^\n]+\n/);
                if (parts.length < 2) return [];

                // Extract the key signature
                const keyMatch = this.currentAbc.match(/K:([A-G][#b]?m?)/);
                const key = keyMatch ? keyMatch[1] : 'C';

                // Get key accidentals
                const keyAccidentals = this.getAccidentalsForKey(key);

                // Get just the musical content
                const musicPart = parts[1]
                    .replace(/\\\s*\n/g, ' ')  // Handle line continuations
                    .replace(/V:\d+/g, ' ')    // Remove voice indicators
                    .replace(/\|/g, ' |')      // Add space after bar lines for easier parsing
                    .replace(/\s+/g, ' ')      // Normalize whitespace
                    .trim();

                // Extract notes with accidentals and octave markers
                const notes = [];
                // Match note pattern: optional accidental (^_=), note letter (A-Ga-g), optional octave markers (',)
                const noteRegex = /([_^=]?)([A-Ga-g])([,']*)/g;
                let match;

                // Track accidentals that apply within a measure
                let measureAccidentals = {};

                while ((match = noteRegex.exec(musicPart)) !== null) {
                    // Skip notes within chord structures
                    if (musicPart.charAt(match.index - 1) === '[') continue;

                    let [, accidental, noteLetter, octaveMarkers] = match;
                    const baseNote = noteLetter.toUpperCase();

                    // Check if we've reached a bar line, and reset measure accidentals if so
                    const textBeforeMatch = musicPart.substring(0, match.index);
                    const lastBarIndex = textBeforeMatch.lastIndexOf('|');
                    const lastNoteIndex = textBeforeMatch.search(/[A-Ga-g][']*$/);

                    if (lastBarIndex > lastNoteIndex && lastBarIndex !== -1) {
                        // We're in a new measure, reset accidentals
                        measureAccidentals = {};
                    }

                    // Apply accidentals in this priority: 
                    // 1. Explicit accidental in the note
                    // 2. Accidental set earlier in the measure
                    // 3. Key signature accidental
                    if (accidental) {
                        // Store explicit accidental for this note in the current measure
                        measureAccidentals[baseNote] = accidental;
                    } else if (measureAccidentals[baseNote]) {
                        // Use accidental already set in this measure
                        accidental = measureAccidentals[baseNote];
                    } else if (keyAccidentals[baseNote]) {
                        // Use key signature accidental
                        accidental = keyAccidentals[baseNote];
                    }

                    const noteName = accidental + noteLetter + octaveMarkers;
                    notes.push(noteName);
                }

                return notes;
            }
        }

        /**
         * Handles all note transposition functionality
         */
        class TransposeManager {
            noteToSemitone(accidental, noteLetter, octaveMarkers) {
                // Base values for each note
                const baseValues = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };

                // Start with base value
                let semitone = baseValues[noteLetter.toUpperCase()];

                // Apply accidentals
                if (accidental) {
                    for (const acc of accidental) {
                        if (acc === '^') semitone += 1;
                        else if (acc === '_') semitone -= 1;
                    }
                }

                // Set octave (C is middle C = octave 4, c is octave 5)
                let octave = noteLetter === noteLetter.toUpperCase() ? 4 : 5;

                // Apply octave markers
                if (octaveMarkers) {
                    for (const marker of octaveMarkers) {
                        if (marker === ',') octave -= 1;
                        else if (marker === "'") octave += 1;
                    }
                }

                // Calculate absolute semitone value
                return semitone + (octave * 12);
            }

            semitoneToAbc(semitone, duration) {
                // Get octave and note value
                const octave = Math.floor(semitone / 12);
                const noteValue = ((semitone % 12) + 12) % 12;

                // Map semitones to note names with accidentals
                const noteMap = [
                    { note: 'C', accidental: '' },
                    { note: 'C', accidental: '^' },
                    { note: 'D', accidental: '' },
                    { note: 'D', accidental: '^' },
                    { note: 'E', accidental: '' },
                    { note: 'F', accidental: '' },
                    { note: 'F', accidental: '^' },
                    { note: 'G', accidental: '' },
                    { note: 'G', accidental: '^' },
                    { note: 'A', accidental: '' },
                    { note: 'A', accidental: '^' },
                    { note: 'B', accidental: '' }
                ];

                // Get note information
                const { note, accidental } = noteMap[noteValue];

                // Format note based on octave
                let formattedNote, octaveMarkers = '';

                if (octave < 4) {
                    // Lower octaves: uppercase with commas
                    formattedNote = note.toUpperCase();
                    octaveMarkers = ','.repeat(4 - octave);
                } else if (octave === 4) {
                    // Middle octave: uppercase
                    formattedNote = note.toUpperCase();
                } else if (octave === 5) {
                    // One octave up: lowercase
                    formattedNote = note.toLowerCase();
                } else {
                    // Higher octaves: lowercase with apostrophes
                    formattedNote = note.toLowerCase();
                    octaveMarkers = "'".repeat(octave - 5);
                }

                return accidental + formattedNote + octaveMarkers + duration;
            }

            transposeKey(keyLine, semitoneShift) {
                const keyMatch = keyLine.match(/K:([A-G][#b]?)([m]?)/);
                if (!keyMatch) return keyLine;

                const [, key, mode] = keyMatch;

                // Map keys to semitones
                const keyToSemitone = {
                    'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
                    'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
                    'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
                };

                // Map semitones to key names
                const semitoneToKey = {
                    0: 'C', 1: 'C#', 2: 'D', 3: 'Eb', 4: 'E', 5: 'F',
                    6: 'F#', 7: 'G', 8: 'Ab', 9: 'A', 10: 'Bb', 11: 'B'
                };

                let semitone = keyToSemitone[key];
                if (semitone === undefined) return keyLine;

                semitone = (semitone + semitoneShift + 12) % 12;
                const newKey = semitoneToKey[semitone];

                return keyLine.replace(/K:[A-G][#b]?[m]?/, `K:${newKey}${mode}`);
            }

            transposeNote(note, semitoneShift) {
                const match = note.match(/([_^=]*)([A-Ga-g])([,']*)([\d/]*)/);
                if (!match) return note;

                const [, accidental, noteLetter, octaveMarkers, duration] = match;

                // Convert to semitone value
                const semitone = this.noteToSemitone(accidental, noteLetter, octaveMarkers);

                // Apply transposition
                const newSemitone = semitone + semitoneShift;

                // Convert back to ABC notation
                return this.semitoneToAbc(newSemitone, duration);
            }

            transposeNotes(noteLines, semitoneShift) {
                const noteRegex = /([_^=]*)([A-Ga-g])([,']*)([\d/]*)/g;

                return noteLines.map(line => {
                    return line.replace(noteRegex, (match) => {
                        return this.transposeNote(match, semitoneShift);
                    });
                });
            }
        }

        /**
         * Manages MIDI playback functionality
         */
        class MidiPlayer {
            constructor() {
                this.midiPlayer = null;
                this.isPlaying = false;
            }

            async init(visualObj) {
                try {
                    // Create MIDI player if not exists
                    if (!this.midiPlayer) {
                        this.midiPlayer = new ABCJS.synth.CreateSynth();

                        // Add event listener for when playback ends
                        this.midiPlayer.onEnded = () => {
                            this.isPlaying = false;
                            document.getElementById('play-button').textContent = '▶';
                        };
                    }

                    // Create the audio context
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Initialize MIDI
                    await this.midiPlayer.init({
                        visualObj: visualObj,
                        audioContext: audioContext,
                        millisecondsPerMeasure: 2000,
                        options: {
                            program: 0,
                            midiTranspose: 0
                        }
                    });

                    // Load and prepare the synth
                    await this.midiPlayer.prime();

                    document.getElementById('play-button').disabled = false;
                    return true;
                } catch (error) {
                    console.error("Error initializing MIDI player:", error);
                    return false;
                }
            }

            async togglePlay() {
                try {
                    if (!this.midiPlayer) {
                        return false;
                    }

                    if (this.isPlaying) {
                        await this.midiPlayer.pause();
                        document.getElementById('play-button').textContent = '▶';
                    } else {
                        await this.midiPlayer.start();
                        document.getElementById('play-button').textContent = '⏸';
                    }
                    this.isPlaying = !this.isPlaying;
                    return true;
                } catch (error) {
                    console.error("Error in togglePlay:", error);
                    return false;
                }
            }

            async restart() {
                try {
                    if (!this.midiPlayer) {
                        return false;
                    }

                    await this.midiPlayer.stop();
                    this.isPlaying = false;
                    document.getElementById('play-button').textContent = '▶';

                    await this.midiPlayer.start();
                    this.isPlaying = true;
                    document.getElementById('play-button').textContent = '⏸';
                    return true;
                } catch (error) {
                    console.error("Error in restart:", error);
                    return false;
                }
            }
        }

        /**
         * Manages visual display of the fingering diagrams on the staff
         */
        class DiagramRenderer {
            constructor(fingeringManager, config) {
                this.fingeringManager = fingeringManager;
                this.config = config;
            }

            addFingeringDiagrams(abcContainer, notesData) {
                // Create container for fingering diagrams
                this.clearFingeringDiagrams();

                const layer = document.createElement('div');
                layer.id = 'fingering-layer';
                layer.style.position = 'absolute';
                layer.style.top = '0';
                layer.style.left = '0';
                layer.style.width = '100%';
                layer.style.height = '100%';
                layer.style.pointerEvents = 'none'; // None for layer, but we'll enable it for diagrams
                layer.style.zIndex = '10';

                abcContainer.style.position = 'relative';
                abcContainer.appendChild(layer);

                // Extract notes from notesData
                const allNotes = notesData;

                // Find note elements
                const allElements = document.querySelectorAll("#abc-notation .abcjs-note");
                const noteElements = Array.from(allElements).filter(el => {
                    // Filter out non-note elements that might have the note class
                    return !el.classList.contains('abcjs-clef') &&
                        !el.classList.contains('abcjs-key-signature') &&
                        !el.classList.contains('abcjs-time-signature') &&
                        !el.classList.contains('abcjs-tempo');
                });

                if (!noteElements.length) return;

                const containerRect = abcContainer.getBoundingClientRect();

                // Group notes by staff line
                const staffLines = this.groupNotesByStaffLine(noteElements);

                // Adjust note list if counts don't match
                let notesToUse = [...allNotes];
                const totalNoteElements = staffLines.reduce((sum, staff) => sum + staff.notes.length, 0);

                if (totalNoteElements !== notesToUse.length) {
                    // Adjust list length to match element count
                    if (totalNoteElements < notesToUse.length) {
                        notesToUse = notesToUse.slice(0, totalNoteElements);
                    } else {
                        // Fill with the last note if we have more elements than notes
                        while (notesToUse.length < totalNoteElements) {
                            notesToUse.push(notesToUse[notesToUse.length - 1] || "?");
                        }
                    }
                }

                // Add this before rendering diagrams
                const validNotes = notesData.filter(note =>
                    this.fingeringManager.getFingeringForNote(note) !== null
                );
                console.log(`Found ${validNotes.length} valid notes out of ${notesData.length}`);

                // Add fingering diagrams for each staff line
                this.renderDiagramsOnStaff(staffLines, notesToUse, containerRect, layer);
            }

            groupNotesByStaffLine(noteElements) {
                const staffLines = [];
                const tolerance = 30; // pixels

                // Create positions map
                const notePositions = noteElements.map(el => {
                    const rect = el.getBoundingClientRect();
                    return {
                        element: el,
                        top: rect.top,
                        left: rect.left,
                        width: rect.width
                    };
                });

                // Group by vertical position
                notePositions.forEach(pos => {
                    let foundStaff = false;
                    for (const staff of staffLines) {
                        if (Math.abs(staff.top - pos.top) <= tolerance) {
                            staff.notes.push(pos);
                            foundStaff = true;
                            break;
                        }
                    }

                    if (!foundStaff) {
                        staffLines.push({
                            top: pos.top,
                            notes: [pos]
                        });
                    }
                });

                // Sort staff lines by vertical position (top to bottom)
                staffLines.sort((a, b) => a.top - b.top);

                // Sort notes within each staff line from left to right
                staffLines.forEach(staff => {
                    staff.notes.sort((a, b) => a.left - b.left);
                });

                return staffLines;
            }

            renderDiagramsOnStaff(staffLines, notesToUse, containerRect, layer) {
                let noteIndex = 0;

                // Create a map of staff elements by their line number
                const staffElementMap = new Map();
                const staffElements = document.querySelectorAll('.abcjs-staff');

                staffElements.forEach(el => {
                    // Look for the abcjs-lN class to determine line number
                    const lineClassMatch = Array.from(el.classList)
                        .find(cls => cls.match(/abcjs-l\d+/));

                    if (lineClassMatch) {
                        const lineNumber = parseInt(lineClassMatch.replace('abcjs-l', ''), 10);
                        staffElementMap.set(lineNumber, el);
                    }
                });

                // Process each staff line
                staffLines.forEach((staff, staffIndex) => {
                    if (staff.notes.length === 0) return;

                    // Find the first note in this staff line and extract its line number from the class
                    const noteElement = staff.notes[0].element;
                    let lineNumber = null;

                    // Look for the closest element with an abcjs-lN class
                    let el = noteElement;
                    while (el && lineNumber === null) {
                        const lineClassMatch = Array.from(el.classList)
                            .find(cls => cls.match(/abcjs-l\d+/));

                        if (lineClassMatch) {
                            lineNumber = parseInt(lineClassMatch.replace('abcjs-l', ''), 10);
                        }
                        el = el.parentElement;
                    }

                    // If we found a line number, get the corresponding staff element
                    const staffElement = lineNumber !== null ? staffElementMap.get(lineNumber) : null;

                    if (!staffElement) return;

                    // Get the staff's position
                    const staffRect = staffElement.getBoundingClientRect();

                    // Position diagrams a consistent distance below the staff bottom
                    const diagramsTopPosition = staffRect.bottom - containerRect.top + this.config.verticalOffset;

                    // Process each note in this staff
                    staff.notes.forEach(note => {
                        if (noteIndex >= notesToUse.length) return;

                        const noteName = notesToUse[noteIndex];
                        const fingeringData = this.fingeringManager.getFingeringForNote(noteName);

                        noteIndex++;
                        if (!fingeringData) return;

                        const diagram = this.fingeringManager.createFingeringDiagram(fingeringData, noteName);

                        // Position horizontally based on note, vertically based on staff
                        diagram.style.position = 'absolute';
                        diagram.style.left = `${note.left - containerRect.left + (note.width / 2)}px`;
                        diagram.style.top = `${diagramsTopPosition}px`;
                        diagram.style.transform = `translate(-50%, 0) scale(${this.config.scale})`;
                        diagram.style.transformOrigin = 'center top';

                        layer.appendChild(diagram);
                    });
                });
            }

            clearFingeringDiagrams() {
                const existing = document.getElementById('fingering-layer');
                if (existing) existing.remove();
            }
        }

        /**
         * Main application controller
         */
        class AbcPlayer {
            constructor() {
                // Configuration for rendering ABC notation
                this.renderConfig = {
                    stafftopmargin: 120,
                    staffbottommargin: 60,
                    oneSvgPerLine: false,
                    scale: 1.0,
                };

                // Config settings for fingering diagrams
                this.fingeringConfig = {
                    showLabels: true,
                    scale: 0.75,
                    verticalOffset: 12,
                    holeSize: 7,
                    holeBorder: 1,
                    holeSpacing: 2,
                    columnSpacing: 6,
                    borderRadius: 4,
                    fontSizeNote: 10,
                    backgroundColor: 'rgba(240, 240, 180, 0.6)',
                    redColor: 'rgba(255, 0, 0, 0.6)',
                    greenColor: 'rgba(0, 128, 0, 0.6)',
                };

                // Initialize sub-modules
                this.notationParser = new NotationParser();
                this.fingeringManager = new FingeringManager(this.fingeringConfig);
                this.transposeManager = new TransposeManager();
                this.midiPlayer = new MidiPlayer();
                this.diagramRenderer = new DiagramRenderer(this.fingeringManager, this.fingeringConfig);

                // Initialize UI handlers
                this.initializeEventListeners();
            }

            render() {
                try {
                    const abcContainer = document.getElementById('abc-notation');
                    this.diagramRenderer.clearFingeringDiagrams();

                    const visualObj = ABCJS.renderAbc("abc-notation", this.notationParser.currentAbc, {
                        responsive: "resize",
                        add_classes: true,
                        staffwidth: window.innerWidth - 60,
                        stafftopmargin: this.renderConfig.stafftopmargin,
                        staffbottommargin: this.renderConfig.staffbottommargin,
                        oneSvgPerLine: this.renderConfig.oneSvgPerLine,
                        scale: this.renderConfig.scale,
                    })[0];

                    // Initialize MIDI player
                    this.midiPlayer.init(visualObj);

                    // Add fingering diagrams after rendering if enabled
                    if (this.fingeringManager.showFingering) {
                        setTimeout(() => {
                            const notes = this.notationParser.extractNotesFromAbc();
                            this.diagramRenderer.addFingeringDiagrams(abcContainer, notes);
                        }, 100);
                    }
                } catch (error) {
                    console.error("Error in render:", error);
                }
            }

            async copyToClipboard() {
                return Utils.copyToClipboard(this.notationParser.currentAbc);
            }

            async pasteFromClipboard() {
                const text = await Utils.readFromClipboard();
                if (text && text.includes('X:') && text.includes('K:')) {
                    this.notationParser.currentAbc = text;
                    this.render();
                    Utils.showFeedback('ABC notation pasted successfully!');
                    return true;
                } else if (text) {
                    alert('Invalid ABC notation format');
                }
                return false;
            }

            transpose(direction) {
                const semitoneShift = direction === 'up' ? 1 : -1;

                // Parse ABC notation
                const sections = this.notationParser.parseAbcSections(this.notationParser.currentAbc);

                // Transpose key if present
                if (sections.key) {
                    sections.key = this.transposeManager.transposeKey(sections.key, semitoneShift);
                }

                // Transpose notes
                sections.notes = this.transposeManager.transposeNotes(sections.notes, semitoneShift);

                this.notationParser.currentAbc = this.notationParser.reconstructAbc(sections);
                this.render();
            }

            toggleReferenceRow() {
                const referenceRow = document.getElementById('reference-row');

                // Toggle visibility directly
                if (referenceRow.style.display === 'none') {
                    referenceRow.style.display = 'flex';
                    document.getElementById('chart-toggle').innerHTML = '&#x2212;'; // Minus sign
                } else {
                    referenceRow.style.display = 'none';
                    document.getElementById('chart-toggle').innerHTML = '&#43;'; // Plus sign
                }
            }

            toggleFingeringSystem() {
                const newSystem = this.fingeringManager.toggleFingeringSystem();
                this.render();
                // Add this line to update the reference row
                this.fingeringManager.populateReferenceRow();
                return newSystem;
            }

            toggleFingeringDisplay() {
                this.fingeringManager.showFingering = !this.fingeringManager.showFingering;
                if (this.fingeringManager.showFingering) {
                    const notes = this.notationParser.extractNotesFromAbc();
                    const abcContainer = document.getElementById('abc-notation');
                    this.diagramRenderer.addFingeringDiagrams(abcContainer, notes);
                } else {
                    this.diagramRenderer.clearFingeringDiagrams();
                }
                return this.fingeringManager.showFingering;
            }

            initializeEventListeners() {
                window.addEventListener('DOMContentLoaded', () => {
                    document.getElementById('reference-row').style.display = 'none';
                    document.getElementById('chart-toggle').innerHTML = '&#43;';
                    this.render();
                    this.fingeringManager.populateReferenceRow();

                    // Play controls
                    document.getElementById('play-button').addEventListener('click', () => {
                        this.midiPlayer.togglePlay();
                    });

                    document.getElementById('restart-button').addEventListener('click', () => {
                        this.midiPlayer.restart();
                    });

                    // Clipboard controls
                    document.getElementById('copy-button').addEventListener('click', () => {
                        this.copyToClipboard();
                    });

                    document.getElementById('paste-button').addEventListener('click', () => {
                        this.pasteFromClipboard();
                    });

                    // Keyboard shortcuts
                    document.addEventListener('keydown', (event) => {
                        if (event.ctrlKey && !event.shiftKey && !event.altKey) {
                            if (event.key === 'c' && !window.getSelection().toString()) {
                                event.preventDefault();
                                this.copyToClipboard();
                            } else if (event.key === 'v') {
                                event.preventDefault();
                                this.pasteFromClipboard();
                            }
                        }
                    });

                    // Transpose controls
                    document.getElementById('transpose-up').addEventListener('click', () => {
                        this.transpose('up');
                    });

                    document.getElementById('transpose-down').addEventListener('click', () => {
                        this.transpose('down');
                    });

                    // Chart toggle
                    document.getElementById('chart-toggle').addEventListener('click', () => {
                        this.toggleReferenceRow();
                    });

                    // Add fingering system toggle button
                    const systemToggle = document.createElement('button');
                    systemToggle.id = 'system-toggle';
                    systemToggle.title = 'Toggle Baroque/German Fingering';
                    systemToggle.textContent = 'German Fingering';
                    systemToggle.addEventListener('click', () => {
                        const newSystem = this.toggleFingeringSystem();
                        systemToggle.textContent = newSystem === 'baroque' ? 'Baroque Fingering' : 'German Fingering';
                    });

                    // Add fingering display toggle
                    const fingeringDisplayToggle = document.createElement('button');
                    fingeringDisplayToggle.id = 'show-fingering';
                    fingeringDisplayToggle.textContent = 'Hide Fingering';
                    fingeringDisplayToggle.title = 'Show/hide fingering diagrams';
                    fingeringDisplayToggle.addEventListener('click', () => {
                        const showFingering = this.toggleFingeringDisplay();
                        fingeringDisplayToggle.textContent = showFingering ? 'Hide Fingering' : 'Show Fingering';
                    });

                    // Add to control bar
                    const controlBar = document.querySelector('.control-bar');
                    controlBar.insertBefore(systemToggle, controlBar.firstChild);
                    controlBar.insertBefore(fingeringDisplayToggle, controlBar.firstChild);

                    // Handle window resize
                    window.addEventListener('resize', Utils.debounce(() => {
                        if (this.fingeringManager.showFingering) {
                            const notes = this.notationParser.extractNotesFromAbc();
                            const abcContainer = document.getElementById('abc-notation');
                            this.diagramRenderer.addFingeringDiagrams(abcContainer, notes);
                        }
                    }, 150));
                });
            }
        }

        // Initialize the application
        const app = new AbcPlayer();
    </script>
</body>

</html>